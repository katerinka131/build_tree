

## Поля класса:
- root: корневой узел дерева
- nodes: словарь всех узлов дерева с их характеристиками
- leaves: множество листьев дерева
- edge_count: счетчик ребер для каждого узла
- edge_types: типы операций для ребер
- max_depth: максимальная глубина дерева

## Структура узла:
- children: список дочерних узлов
- parent: родительский узел
- depth: глубина узла
- op: операция, которая привела к созданию узла
- edge_count: количество исходящих ребер
- name: имя узла

## Основные функции

### 1. find_evolution_path(root, leaf)
Находит оптимальный путь преобразования от корневого узла к листу с использованием трех операций:

Операции:
- add: добавление символа в конец
- del: удаление символа
- sub: замена символа

Алгоритм работы:
1. Посимвольное сравнение корня и листа
2. Обнаружение расхождений и определение необходимых операций
3. Оптимизация последовательности операций для минимизации длины пути

### 2. add_node(parent, child, op, depth)
Добавляет новый узел в дерево с проверкой ограничений:

### Ограничения:
- Максимум 3 потомка у каждого узла


### 3. get_available_nodes(max_edges=3)
Возвращает список узлов, к которым можно добавить новых потомков (имеющих менее 3 ребер).

### 4. add_path_to_tree(path_sequence, leaf, current_node)
Добавляет весь путь последовательности операций в дерево, начиная с указанного узла.

### 5. visualize()
Создает визуальное представление дерева с использованием Graphviz:
- Узлы отображаются с информацией о глубине и количестве ребер
- Ребра окрашены в зависимости от типа операции:
   - Зеленый: добавление
   - Красный: удаление
   - Синий: замена

## Алгоритм построения

## Функция build_optimal_tree(root, leaves)

### Шаг 1: Инициализация
- Создание дерева с корневым узлом
- Инициализация множества листьев

### Шаг 2: Поиск и сортировка путей
- Для каждого листа находится путь от корня
- Пути сортируются по длине (от самого длинного)

### Шаг 3: Построение самого длинного пути
- Самый длинный путь добавляется в дерево первым

### Шаг 4: Обработка оставшихся листьев
Для каждого оставшегося листа:
1. Получение доступных узлов (с менее чем 3 потомками)
2. Для каждого доступного узла:
    - Нахождение пути от узла к листу
    - Вычисление score = (глубина_узла + длина_пути, доступные_ребра)
 3. Выбор узла с минимальным score
 4. Добавление пути от выбранного узла к листу

### Шаг 5: Возврат построенного дерева

### Функция build(root, leaves)
 Альтернативная упрощенная версия, которая строит дерево путем добавления 
 всех путей непосредственно от корня без оптимизации.

### Запуск программы
В файле tree_data.py указать корень и листья дерева.

Запустить программу через команду:

```
python3 genetic.py
```
